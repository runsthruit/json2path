#! /bin/bash

function json2path ()
{

	declare __bash_function_init_{opts,{locv,glbv}_{strings,arrays}}=
	__bash_function_init_opts=(
		method
	)
	__bash_function_init_locv_strings=(
		JSON
		OUT{,_{CUR,VAL}}
		STG{,BAK}
		ENT{,BAK}
		CHR_{DBQ,ESC}

	)
	__bash_function_init_locv_arrays=(
		JSONS
		RGXS
	)
	__bash_function_init_glbv_strings=()
	__bash_function_init_glbv_arrays=()
	: BASH_FUNCTION_INIT SOURCE; eval "$( bash_function_init || echo return 1 )"

	RGXS=(
		PAR="\"([^\"]*)\"[[:space:]]*:"
		NXT="(,)"
		WORD="(true|false|null)"
		NUMBER="([0-9\.eE\+-]+)"
		STRING_EDQ="\"+([^\"]*[\\][\"][^\"]*)\""
		STRING="\"([^\"]*)\""
		OBJ_NUL="({})"
		OBJ_BEG="({)"
		OBJ_END="(})"
		ARY_NUL="(\[\])"
		ARY_BEG="(\[)"
		ARY_END="(\])"
		ERR="(.*)"
	)
	LVL=0
	STG=NOP
	CHR_DBQ="\""
	CHR_ESC="\\"

	[ "${#ARGS[@]}" -gt 0 ] \
	&& JSONS=( "${ARGS[@]}" ) \
	|| [ -t 0 ] \
	|| JSONS[0]="-"

	for (( I=0; I<${#JSONS[@]}; I++ ))
	do

	[[ "${JSONS[${I}]}" =~ (${RGXS[0]}|^(${RGXS[7]}|${RGXS[10]})) ]] \
	&& CMD=( echo "${JSONS[${I}]}" ) \
	|| [ "${JSONS[${I}]}" == "-" ] \
	&& CMD=( cat - ) \
	|| [ -r "${JSONS[${I}]}" ] \
	&& CMD=( cat "${JSONS[${I}]}" ) \
	|| { printf "${FNC}: %s\n" "Could not read ( ${JSONS[${I}]} )"; return 1; } 1>&2

	case "${OPT_method}" in
	( 9 ) {

	eval "${CMD[@]}" |
	while IFS="${TAB}${NLN}${CRT}" read -r -n1 ENT
	do
		#
		[ -n "${ENT}" ] || continue
		#
		[[ "${STG}" == NOP* ]] || STGBAK="${STG}"
		case "${STG}" in
		( STR* ) :;;
		( * ) {
			case "${ENT}" in
			( "${CHR_DBQ}" )	STG=STR;;
			( " " )			STG=NOP_SPC;;
			( ":" )			STG=PAR;;
			( "," )			STG=NXT;;
			( [0-9\.eE\+-] )	STG=VAL_NUM;;
			( [TtFf] )		STG=VAL_FLG;;
			( [Nn] )		STG=VAL_NUL;;
			( [RUErueFALSfals] )	[[ "${STGBAK}" == VAL_* ]] || STG=ERR;;
			( "[" )			STG=ARY_BEG;;
			( "]" )			STG=ARY_END;;
			( "{" )			STG=OBJ_BEG;;
			( "}" )			STG=OBJ_END;;
			( * )			STG=ERR;;
			esac
		};;
		esac
		case "${STG}" in
		( STR* ) {
			#[[ "${STGBAK}" == STR* ]] || OUT_VAL=
			OUT_VAL="${OUT_VAL}${ENT}"
			case "${STG}" in
			( STR_REG ) {
				case "${ENT}" in
				( "${CHR_DBQ}" )	STG=NOP;;
				( "${CHR_ESC}" )	STG=STR_ESC;;
				esac
			};;
			( STR* )			STG=STR_REG;;
			esac
		};;
		( PAR ) {
			OUT_VAL="${OUT_VAL#\"}"
			OUT_VAL="${OUT_VAL%\"}"
			OUT_CUR="${OUT_CUR}${OUT_VAL}"
			OUT_VAL=
		};;
		( VAL* ) {
			#[[ "${STGBAK}" == VAL* ]] || OUT_VAL=
			OUT_VAL="${OUT_VAL}${ENT}"
		};;
		( OBJ_BEG ) {
			OUT_CUR="${OUT_CUR}/"
		};;
		( ARY_BEG ) {
			OUT_CUR="${OUT_CUR}[0]"
		};;
		( NXT | *_END ) {
			[[ "${STGBAK}" == STR* || "${STGBAK}" == VAL* || "${OUT_CUR}" == *= ]] \
			&& {
				printf "%s%s\n" "${OUT_CUR}" "${OUT_VAL:+=${OUT_VAL}}"
				OUT_VAL=
			}
			case "${STG}" in
			( NXT ) {
				[[ "${OUT_CUR}" =~ (.*)\[([-]?[0-9]*)\]$ ]] \
				&& OUT_CUR="${BASH_REMATCH[1]}[$((${BASH_REMATCH[2]}+1))]" \
				|| OUT_CUR="${OUT_CUR%/*}/"
			};;
			( OBJ_END ) {
				OUT_CUR="${OUT_CUR%/*}"
			};;
			( ARY_END ) {
				[ "${STGBAK}" == "ARY_BEG" ] \
				&& OUT_CUR="${OUT_CUR%\[*\]}[-1]=" \
				|| OUT_CUR="${OUT_CUR%\[*\]}"
			};;
			esac
		};;
		esac
		#
		#[[ "${STG}" == NOP* || "${STG}" == STR* ]] || \
		#printf "# %10s  %4q  %-60s  %q\n" "${STG}" "${ENT}" "${OUT_CUR}" "${OUT_VAL}"
		#
		[ -z "${ENT}" ] || ENTBAK="${ENT}"
		#sleep 0.1 || break
	done

	};;
	( * ) {

	eval "${CMD[@]}" |
	{
		case "${OPT_method}" in
		( 1 ) {
			sed "s/\"[^\"]*\":/${TAB}&/g" |
			tr "\t" "\n"
		};;
		( 0 ) {
			tr "\t" "\0" |
			sed "s/\"[^\"]*\":/${TAB}&/g" |
			tr "\t" "\n" |
			tr "\0" "\t"
		};;
		( * ) {
			cat -
		};;
		esac
	} |
	while read -r JSON
	do
	while [ -n "${JSON}" ]
	do
		OUT_CUR="${OUT_CUR%=}"
		OUT_VAL=
		[ "${DBG}" -lt 4 ] \
		|| {
			echo
			printf "%sJSON %s\n" "#" "${#JSON}"
			printf "%sJSON=%q\n" "$" "${JSON}" | cut -b1-${COLUMNS}
		} 1>&2
		for ENT in "${RGXS[@]}"
		do
			RGX="^[[:space:]]*${ENT#*=}[[:space:]]*(.*)"
			RGX_TYP="${ENT%%=*}"
			[[ "${JSON}" =~ ${RGX} ]] || continue
			[ "${DBG}" -lt 3 ] \
			|| {
				echo
				for (( I=0; I<${#BASH_REMATCH[@]}; I++ ))
				do
					printf "%sBASH_REMATCH[%s] %s\n" "#" "${I}" "${#BASH_REMATCH[${I}]}"
					printf "%sBASH_REMATCH[%s]=%q\n" "$" "${I}" "${BASH_REMATCH[${I}]}" | cut -b1-${COLUMNS}
				done
			} 1>&2
			JSON="${BASH_REMATCH[2]}"
			case "${RGX_TYP}" in
				( PAR ) {
					OUT_CUR="${OUT_CUR}${BASH_REMATCH[1]}"
				};;
				( NXT ) {
					[[ "${OUT_CUR}" =~ ^(.*)\[([0-9]*)\]$ ]] \
					&& OUT_CUR="${BASH_REMATCH[1]}[$((${BASH_REMATCH[2]}+1))]" \
					|| OUT_CUR="${OUT_CUR%/*}/"
				};;
				( WORD | NUMBER ) {
					OUT_CUR="${OUT_CUR}="
					OUT_VAL="${BASH_REMATCH[1]}"
				};;
				( STRING* ) {
					OUT_CUR="${OUT_CUR}="
					OUT_VAL="\"${BASH_REMATCH[1]}\""
				};;
				( OBJ_NUL ) {
					:
				};;
				( OBJ_BEG ) {
					OUT_CUR="${OUT_CUR}/"
				};;
				( OBJ_END ) {
					OUT_CUR="${OUT_CUR%/*}"
				};;
				( ARY_NUL ) {
					OUT_CUR="${OUT_CUR}[-1]="
				};;
				( ARY_BEG ) {
					OUT_CUR="${OUT_CUR}[0]"
				};;
				( ARY_END ) {
					OUT_CUR="${OUT_CUR%\[*\]}"
				};;
				( ERR ) {
					echo BAD_JSON
					return 2
				};;
				( * ) {
					echo RGX_ERROR
					return 1
				};;
			esac
			break
		done
		[ "${DBG}" -lt 4 ] \
		|| {
			echo
			declare -p OUT_{CUR,VAL} | sed "s/^declare [^ ]* /\$/" | cut -b1-${COLUMNS}
		} 1>&2
		[ "${DBG}" -lt 3 ] || printf "\n" 1>&2
		[ "${DBG}" -lt 1 ] || printf "%12s\n" "${RGX_TYP}" 1>&2
		[[ "${OUT_CUR}" != *= ]] || printf "%s\n" "${OUT_CUR%=}${OUT_VAL:+=${OUT_VAL}}"
		[ "${DBG}" -lt 2 ] || printf "%s\n" "${OUT_CUR%=}${OUT_VAL:+=${OUT_VAL}}" 1>&2
	done
	done

	};;
	esac

	done

}

: BASH_FUNCTION_INIT RUN; I="${BASH_SOURCE[0]##*/}"; [ "${I}" != "${0}" -a "${#BASH_SOURCE[@]}" -ne 0 ] || ${I%.*} ${@:+"${@}"}
